
#include "Header.h"

void sas1() {

    /*
    ****    Семантика копирования - инициализация класса, путем создания копии объекта его другому (медленно)
    * 
    ****    Семантика перемещения - копирование одного класса в другой (быстро)
    * 
    ****    Функция std::move() — это стандартная библиотечная функция, которая конвертирует передаваемый аргумент в r-value. 
    *       Мы можем передать l-value в функцию std::move(), и std::move() вернет нам ссылку r-value. 
    *       Для работы с std::move() нужно подключить заголовочный файл utility.
    */

    const int ref1 = 12;                // константная ссылка l-value на r-value (продолжение жизни литерала)
    // ref1 = 9;                        // невозможно, ссылка не константная, а литерал не r-value
    int &&ref2 = 12;                    // ссылка r-value на литерал (создается копия литерала)
    ref2 = 9;                           // возможно, ссылка изменяет копию
    int &&h = int(2);                   // возможность ссылаться на анонимы

   
    Auto_ptr<int> ptr1(new int(12));    // умный указатель для работы с динамической памятью (см. реализаию Header.h)

    Auto_ptr<Item> mainItem;
    mainItem = generatItem();           // после вызова функции копия создастся 3 раза c использыванием ссылок! <- беда при использовании копирования
                                        // автоматические объекты, возвращаемые функцией по значению, можно перемещать, даже если они являются l-values.
                                        // при обработке конструктора перемещения мы лишь перераспределим ресурсы

    std::vector<std::string> v;
    std::string str = "Bye";

    v.push_back(str);                   // str - l-value <- используется семантика копирования
    v.push_back(std::move(str));        // std::move(str) - r-value <- используется семантика перемещения
}

void sas2() {

    /*
    ****    Умный указатель std::unique_ptr является заменой std::auto_ptr в C++11.
    *   Вы должны использовать именно его для управления любым динамически выделенным объектом/ресурсом, но с условием,
    *   что std::unique_ptr полностью владеет переданным ему объектом, а не делится «владением» еще с другими классами.
    *   Умный указатель std::unique_ptr находится в заголовочном файле memory.
    * 
    ****    std::unique_ptr достаточно умен, чтобы знать, когда использовать единичный оператор delete, а когда форму оператора delete для массива,
    *   поэтому std::unique_ptr можно использовать как с единичными объектами, так и с динамическими массивами.
    * 
    ****  std::make_unique() - Это шаблон функции, который создает объект типа шаблона и инициализирует его аргументами, переданными в функцию.   
    * 
    ****    Главное отличие - это порядок выполнения, например в параметрах функйии, если unique_ptr может сначала выделить память, 
    *   и только потом столкнуться с исключением, из-за чего будет утечка памяти, т.к. память запросили, а адрес не запомнили
    *   std::make_unicue выполняет все действия полследовательно (создался, вызвал, взял, запомнил), не отвлекаясь на другие действия
    * 
    ****    std::unique_ptr как возвращаемое значение функции: при возврате используется семантика перемещения,
    *   если нет объекта, в который нужно осуществить перемещения, то std::unique_ptr просто выйдет из области видимости callera!
    * 
    ****    std::unique_ptr как параметр функции: если передать std::unique_ptr в функцию по значанию, то опять же произойдет семантика перемещения,
    *   право собственности будет у функции, и в ее конце указатель выйдет из области видимости. Если передать по ссылке, то этого не произойдет, как
    *   и самой семантики перемещения, т.к. ссылка - это псевдоним объекта
    */

    std::unique_ptr<Item> item1(new Item);      // владеет объектом
    std::unique_ptr<Item> item2;                // nullptr

    std::cout <<
        "item1 is:\t" << (item1 ? "not null!\n" : "    null!\n") <<         // not null (неявное преобразование в тип bool)
        "item2 is:\t" << (item2 ? "not null!\n" : "    null!\n");           // null

    item2 = std::move(item1);                   // семантика копирования по умолчанию отключена, используем ссылку r-value для семантики перемещения

    std::cout << "\n" <<
        //"item1 is:\t" << (item1 ? "not null!\n" : "    null!\n") <<       // null (item1 больше не владеет динамическийм объектом)
        "item2 is:\t" << (item2 ? "not null!\n" : "    null!\n");           // nut null (владение объектом передано!)


    try                                                                     // try-блок есть и в конструкторе
    {
        std::unique_ptr<Fraction> dptr = std::make_unique<Fraction>(1, 9);  // создаем объект с динамически выделенным Fraction
        std::cout << *dptr << '\n';                                         // оператор * уже перегружен для unique_ptr, cout перегружен для Fraction 

        auto pt = std::make_unique<Fraction>(1, 100);                       // auto для удобства
        auto d = std::make_unique<Fraction[]>(4);                           // динамический массив с Fraction[4] по умолчанию (0/1)

        std::cout << *pt << ' ' << d[2] << '\n';
    }
    catch (std::exception &except) { std::cerr << except.what(); }          // на всякий случай
}

void sas3() {

    /*
    ****    std::shared_ptr предназначен для случаев, когда несколько умных указателей совместно владеют одним динамически выделенным ресурсом.
    * 
    ****    (!) Правило: 
    *           Всегда выполняйте копирование существующего std::shared_ptr, если вам нужно более одного std::shared_ptr, 
    *           указывающего на один и тот же динамически выделенный ресурс.
    * 
    ****    Как функцию std::make_unique() можно использовать для создания std::unique_ptr в C++14, так и функцию std::make_shared()
    *   можно (и нужно) использовать для создания std::shared_ptr. Функцию std::make_shared() добавили в C++11.
    * 
    ****    В отличие от std::unique_ptr, который использует внутри («под капотом») один указатель, std::shared_ptr использует внутри два указателя. 
    *   Один указывает на передаваемый ресурс, а второй — на «блок управления» — динамически выделенный объект, который отслеживает кучу разных вещей,
    *   включая и то, сколько умных указателей std::shared_ptr одновременно указывают на каждый полученный ресурс.
    *   При создании std::shared_ptr с помощью конструктора std::shared_ptr, память для полученного ресурса и блока управления (
    *   который также создает конструктор) выделяется отдельно. Однако в std::make_shared() это оптимизировано в единое выделение памяти, что,
    *   соответственно, повышает производительность.
    * 
    ****    Умный указатель std::unique_ptr может быть конвертирован в умный указатель std::shared_ptr через специальный конструктор std::shared_ptr, 
    *   который принимает std::unique_ptr в качестве r-value. Таким образом, содержимое std::unique_ptr перемещается в std::shared_ptr.
    * 
    ****    У умного указателя std::shared_ptr есть некоторые из проблем, которые имеет std::unique_ptr.
    *   Если std::shared_ptr не уничтожается должным образом (либо потому, что он был динамически выделен и не удален должным образом,
    *   либо потому, что он был частью объекта, который был динамически выделен и не удален), тогда ресурс, которым управляет std::shared_ptr, 
    *   тоже не будет удален. С std::unique_ptr вам нужно беспокоиться об удалении лишь одного указателя. 
    *   А с std::shared_ptr вам придется беспокоиться об удалении всех указателей, владеющих ресурсом. Если какой-либо из std::shared_ptr, 
    *   владеющий ресурсом, не будет должным образом уничтожен, то и сам ресурс также не будет уничтожен.
    * 
    ****    В C++14 и в более ранних версиях С++ std::shared_ptr не имеет поддержки управления динамическими массивами и, соответственно,
    *   не должен использоваться с ними. Начиная с C++17, в std::shared_ptr добавили поддержку динамических массивов. 
    *   Однако в C++17 «забыли» добавить эту поддержку в std::make_shared(), поэтому данную функцию не следует использовать для создания std::shared_ptr, 
    *   указывающего на динамические массивы.
    */

    {
        Item *item = new Item;                      // динамически создаем объект
        std::shared_ptr<Item> ptr1(item);           // создаем указатель на этот объект
        {
            std::shared_ptr<Item> ptr2(ptr1);       // используем копирующую инициализацию для создания второго std::shared_ptr из ptr1, указывающего на тот же Item 
                                                    // используя семантику перемещения
            std::cout << "Killing one shared pointer\n";
        } // ptr2 выходит из области видимости здесь, но больше ничего не происходит

        std::cout << "Killing another shared pointer\n";

    } //ptr1 выходит из области видимости

    std::cout << std::endl;

    try
    {
        Item *item = new Item;
        std::shared_ptr<Item> ptr1(item);
        {   // это строка в дальнейшем сломает программу!
            //std::shared_ptr<Item> ptr2(item);       // создаем ptr2 напрямую из item (вместо ptr1) указатели не знают друг о друге!

            std::cout << "Killing one shared pointer\n";
        } // ptr2 выходит из области видимости здесь, и выделенный Item уничтожается также здесь

        std::cout << "Killing another shared pointer\n";
    } // ptr1 выходит из области видимости (исключение выбрасывается здесь! мы не можем его поймать!)
    catch (...)
    {
        std::cout << "\nException!\n";
    }

    std::cout << std::endl;

    { 
        auto ptr1 = std::make_shared<Item>();       // Выделяем Item и передаем его в std::shared_ptr
        {
            auto ptr2(ptr1);                        // создаем ptr2 из ptr1, используя семантику копирования

            std::cout << "Killing one shared pointer\n";
        } // ptr2 выходит из области видимости здесь, но ничего больше не происходит, ptr1 еще владеет объектом и знает о всех его владельцах (Item еще жив!)

        std::cout << "Killing another shared pointer\n";

    } // ptr1 выходит из области видимости здесь, и выделенный Item также уничтожается здесь
}

void sas4() {

    /*
    ****    Циклическая зависимость (или «циклические ссылки») — это серия «ссылок», где текущий объект ссылается на следующий, а последний объект ссылается на первый.
    * 
    ****    Упрощенная циклическая зависимость - когда элемент ссылается сам на себя. 
    *   Например, указатель какого-то класса ссылается на объект этого класса, в котором он находится
    * 
    ****    Умный указатель std::weak_ptr был разработан для решения проблемы «циклической зависимости», описанной выше. 
    *   std::weak_ptr является наблюдателем — он может наблюдать и получать доступ к тому же объекту, 
    *   на который указывает std::shared_ptr (или другой std::weak_ptr), но не считаться владельцем этого объекта. 
    *   Помните, когда std::shared_ptr выходит из области видимости, он проверяет, есть ли другие владельцы std::shared_ptr. std::weak_ptr владельцем не считается!
    */

    {
        auto ptr = std::make_shared<Item>();        // создается объект

        ptr->m_ptr = ptr;                           // указатель объекта указывает сам на себя

    }   // из-за того, что есть другие std::shered_ptr (в самом классе) наш объект никогда не выходит из области видимости

    {
        auto ptr = std::make_shared<Item>();        // создается объект

        ptr->m_ptr2 = ptr;                          // weak_ptr указывает на свой объект класса (m_ptr2)

    }   // объект уничтожается, т.к. std::shered_ptr не видит других указателей

}

int main()
{
    //sas1();
    //sas2();
    //sas3();
    sas4();

    return 0;
}

